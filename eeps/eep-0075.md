    Author: Lukas Backström <lukas@erlang.org>
    Status: Draft
    Type: Standards Track
    Created: 26-Nov-2024
    Erlang-Version: OTP-29.0
    Post-History:
****
EEP 75: Native records
----------------------

Abstract
========

This EEP proposes to make records a native datatype to Erlang instead
of a layer on top of tuples. The old tuple-records will remain for
backwards compatibility but the purpose of the native-records is to
replace all current usages of tuple-records. Native-records are tied
to a specific module and use the same syntax as tuple-records except
for declaration.

Example:

```erlang
-module(average).
-export([start/0]).

%% New record declaration syntax.
-record #state{ values = [] :: list(number()), avg = 0.0 :: float() }.

start() ->
  spawn(fun() -> loop(#state{}) end.

loop(State) ->
  receive
    {get_avg, From} -> From ! State#state.avg, loop();
    {get_values, From} -> From ! State#state.avg, loop(State#state{ values = [], avg = 0.0 });
    {put_value, Value} ->
      Values = [Value | State#state.values],
      loop(State#state{ values = Values, avg = lists:sum(Values) / length(Values) })
  end.
```

Goals
=====

1. Replace all tuple-record usage scenarios
2. Replace most tuple-record usages without having to update anything but the declaration. This includes:
    1. All record syntax (create, read, update, match, key index)
    2. Usage in lists:key* + ets functions
    3. Usage of record bifs (`record_info`)
3. Create something that is useful in building both APIs and keeping internal state.
4. Allows IDEs + static analysis tools to easily infer information about the keys.

Should we allow element/2 to take a native-record? yes

What should record-index return? an atom? a number? an atom.

Non-Goals
=========
 
1. Allow variable key lookup
2. Allow variable record name
3. Disallow creation of records in guards

Description
===========

### Native-record definitions

A native-record is a data structure for holding a fixed number of elements in named fields.
Similar to functions, native-records are defined in a module and can be exported or kept private.
A native-record definition consists of the name of the native-record, a list of type parameters
and the field names. Native-Record and field names must be atoms. Type parameters must be variables.

Formally:

```erlang
-record #Name(TVar1, ..., TVarN) {
             Field1 [= Value1] [:: Type1],
             ...
             FieldN [= ValueN] [:: TypeN]
}.
```

`Name` and `FieldN` need to be atoms. `Name` is allowed to be used without quotes
when it is a keyword, a variable or a non-ascii string. That is `div` and `Tillstånd`
is allowed as a `Name` without writing it as `'div'` or `'Tillstånd'`.

By default a native-record definition is visible to the defining module only. It
is visible to other modules if exported via `-export_record()` directive. The
`export_record` directive is similar to `-export()` and `export_type()` directives.

Examples:

```erlang
-module(example).
-export_record([user, pair]).
-record #user{
  id = -1 :: integer(),
  name :: binary(),
  city :: binary()
}.
-record #pair(A, B) {
  first :: A,
  second :: B
}.
-record #state{
    count
}.
```

The order of the keys as declared is preserved and part of the native-record
definition. When printed the fields are printed in the order defined and it
is also possible to get the field index by using the `#Name.Field` syntax.

> **TODO**: Do we have a maximum number of fields?

### -import_record()

As it can be seen from the next sections, working with native-records outside of
the defining module needs using fully qualified names of the native-records:
`#misc:user{}`, ... This quickly may become too cumbersome and verbose. The
-import_record directive works similar to the -import and `-import_type` directives.
Imported native-records can be used by their short names.

```erlang
-module(example2).
-import_record(example1, [user, pair]).
```

### Creating native-records

The following expression creates a new user native-record (in the same module misc where the native-record is
defined):

```erlang
#user{name = ~"John", city = ~"Stockholm"}
```

The next expression is used to create a new user native-record outside of the defining module:

```erlang
#misc:user{name = ~"John"~, city = ~"Stockholm"}
```

Similar to function calls, in this case the fully qualified name must be used (module name +
native-record name). The same syntax can also be used within the defining module
to create a record of the latest version of the module. That is if the current module
has been upgraded it will create a native-record with the new definition. There is no
way to externally refer to a native-record of an old code generation.

A native-record can be imported via `-import_record` directive and then used by its short name.

```erlang
-module(example).
-import_record(misc, [user]).
make_user(Name, City) ->
  #user{name = Name, city = City}.
```

A general syntax for native-record creation:

```erlang
#Name{Field1 = Expr1, ..., FieldN = ExprN}
#Module:Name{Field1 = Expr1, ..., FieldN = ExprN}
```

`Module`, `Field1`, .. `FieldN` must be atoms. `Name` must be a atom, but does not
need quotation for keywords, variables and non-ascii. Fields can be in any order.
The compiler validates that all `Field1`, ..., `FieldN` are unique, and if defined in the
same module it will issue a warning if keys are not present.

#### Default values

If no value is provided for a field and there is a default field value in the
native-record definition, the default value is used. If no value is provided for
a field and there is no default field value then a native-record creation fails
with a badrecord error..

Default values can be any expression. If variables are used or defined within a
default value its scope is limited to that default value.

Example:

```erlang
-record #default{
    one = #other:record{},
    two = gb_tree:new(),
    three = begin A = gb_tree:new(), gb_sets:add_element(initial, A) end
}.
```

#### Validation

A native-record creation is validated at runtime against the native-record
definition. It fails with a badrecord error in the following cases:

- There is no corresponding native-record definition
- The native-record definition is not visible at the call site (it’s not exported).
- The native-record create expression references the field FN which is not defined (in the structure definition)
- No value is provided for a field FN and the native-record definition has no default value for FN.

#### Native-Record values and native-record definitions at runtime

Now that we have seen how to define and create native-records, it makes sense to specify how they
behave at runtime, particularly in the context of Erlang's dynamic nature.
Native-Records in this proposal are designed to support Erlang dynamism in a flexible way. The main
scenarios:

- Code upgrade:
    - Native-record definitions can be upgraded (or even removed)
- Distributed Erlang:
    - Native-records can travel between the Erlang nodes having different versions of code.

From now on let’s employ more precise terminology (when needed): __native-record definitions__ and __native-record values__.

When a native-record value is created, it “captures” key information from the current native-record definition, namely:

- They fully qualified name of the native-record (module name and native-record name)
- Field names
- Whether it’s exported (through `-export_record`)

The runtime needs the current native-record definition to perform create and update operations.

However, to perform read operations on native-record values: accessing native-record fields and pattern
matching over native-record values, the runtime doesn’t consult the current native-record definition.

To minimize the ambiguity of the next sections we would use more verbose wording:

- The fields of a native-record value
- The fields of a native-record definition
- The native-record value is exported
- The native-record definition is exported

In the simplest case - a single Erlang node without code reloading, native-record values and native-record
definitions would always be in sync.

### Accessing native-record fields

The syntax for accessing native-record fields is as follows:

```erlang
Expr#Name.Field
Expr#Module:Name.Field
```

These expressions return the value of the specified field of the native-record value.

An access operation fails with a badfield error if:

- The native-record value is not visible at the call site (the native-record is not exported and is used outside of the defining module)
- The field Field is not defined in the native-record value

The expression can be used in guards - a guard would fail if the corresponding expression raises.

### Updating native-records

The syntax for updating native-record values:

```erlang
Expr#Name{Field1=Expr1, ..., FieldN=ExprN}
Expr#Module:Name{Field1=Expr1, ..., FieldN=ExprN}
```

Field names must be atoms.

A native-record value is updated according to the their native-record definition.

An update operation fails with a badrecord error if:

- The native-record definition is not visible at the call site (the native-record not exported).
- The native-record update expression references the field FN which is not defined (in the structure definition)

Native-Record update expressions are not allowed in guards (similar to tuple-record update expressions).

### Pattern matching over native-records

Pattern matching over native-records is performed similar to maps. A pattern
that matches a certain native-record value is created in the same way as a
native-record is created.

> **TODO**: Can you match on the name of an non-exported function? Probably yes.

The syntax:

```erlang
#Name{Field1 = Expr1, ..., FieldN = ExprN}
#Module:Name{Field1 = Expr1, ..., FieldN = ExprN}
```

Here, `Expr1`, .. `ExprN` are patterns, Field names must be atoms.

Pattern matching fails if:

- The native-record value is not visible at the call site
- The pattern references a FieldK and the native-record value doesn’t contain this field.

> **TODO**: Do we need a way to check that the native-record is the current version.
> The only way right now is to do `record:get_fields(Record) == record:get_fields(#Module:Record{})`
> and that is not always possible.

### Fetching field index

To keep backward compatibility with tuple-records the record index syntax will
be allowed. It will return the atom name of the field. As such it is not
useful except for backwards compatible code.

The native-record field can be used by `element/2` and to get the value of the
field.

Example:

```erlang
-record #user{
  id = -1 :: integer(),
  name :: binary(),
  city :: binary()
}.

id = #user.id.
name = #misc:user.name.
city = #user.city.

-1 = element(#user.id, #user{}).
```

#### element/2

```erlang
-spec erlang:element(atom(), record()) -> term();
                    (pos_integer(), tuple()) -> term().
-spec erlang:tuple_element(pos_integer(), tuple()) -> term().
-spec erlang:record_field(atom(), record()) -> term().
```

#### ETS / lists

We add possibility to have an atom index alongside the integer index.
We also update the lists module to work on atoms+native-records.
The lists:key functions will not work on mixed lists, that is
lists with both tuple- and native-records.

### Native-record guard bifs

- ```erlang
  -spec is_record(Module :: module(), Name :: atom(), Record :: record()) -> boolean();
                 (Name :: atom(), Arity :: non_neg_integer(), Record :: tuple()) -> boolean()
  ```

  The predicate returns true if the term is a native-record value with the corresponding
  native-record name and the native-record is visible (via export) at the call site.

  > **TODO**: Should this fail if the record definition of `Record` does not match
  > the current definition of `#Module:Name{}`? I think probably yes.

  Example:

  ```erlang
  -module(example).
  is_user(U) -> is_record(U, misc, user).
  ```

- ```erlang
  -spec is_record(Name, Record) -> boolean().
  ```

  `is_record/2` is a syntactic sugar which is unfolded into `is_record/3` by the compiler.
  `Name` argument must be an atom. The compiler resolves the fully qualified name of a native-record.
  The native-record must be defined in the same module or imported. The compiler will
  return an error if the native-record does not exist.

  Examples:

  ```erlang
  -module(misc).
  -record #user() {...}.
  is_user(U) when is_record(U, user) ->
      true;
  is_user(_U) ->
      false.
  ```
  
  <!-- -->

  ```erlang
  -module(example).
  -import_record(misc, [user/0]).
  is_user(U) -> is_record(U, user).
  ```

- ```erlang
  -spec is_record(Record) -> boolean().
  ```

  `is_record(Record)` returns true if `Record` is a native-record value (with any name).

- ```erlang
  -spec record_field(Field :: atom(), Record) -> term().
  -spec record_field(Field :: atom(), Module, Record) -> term().
  -spec record_field(Field :: atom(), Module, Name, Record) -> term().
  ```

  Returns the value at `Field`.

- ```erlang
  -spec record_info(fields, Record) -> [atom()];
                   (size, Record) -> non_neg_integer().
  ```

  Backward compatibility bif used for fetching fields and size. You should
  be using `record` module instead.

### Native-records in specs and in the language of types

Native-records that can be used as types using the following syntax:

```erlang
% local or imported native-record
#RecordName(TVar1, ..., TVarN)
#RecordName{TField :: TType, ... }
#RecordName(TVar1, ..., TVarN){ TField :: TType, ... }
% remote native-record
#Module:RecordName(TVar1, ..., TVarN)
```

If you export a native-record, its type will be available for other modules to use.
Dialyzer will complain if you use an un-exported native-record.

Example:

```erlang
-module(misc).
-export_record([user/0, pair/2]).
-record #user() {
    id = -1 :: integer(),
    name :: binary(),
    city :: binary()
}.
-record #pair(A, B) {
    first :: A,
    second :: B
}.
-type int_pair() :: #pair(integer(), integer()).
-spec mk_user() -> #user{ id :: pos_integer() }.
mk_user() ->
    #user{id = 1, name = ~"Alice", city = ~"London"}.
-spec mk_user_limited() -> #user{ id :: pos_integer() }.
mk_user() ->
    #user{id = 1, name = ~"Alice", city = ~"London"}.
-spec mk_pair(A, B) -> #pair(A, B).
mk_pair(A, B) ->
    #pair{first = A, second = B}.
```

A new builtin type `record()` is introduced. It denotes the set of all possible native-record values at runtime.

### Documentation

Native-records can be documented just as functions/types/callbacks can be documented.
If you export a record it will be visible and you have to add `-doc false.`
for it to not be shown.

If in a spec, type, callback or native-record refer to an undocumented
local native-record, the compiler will issue a warning.

### Compatibility in between 28 and 29

In between nodes we transpile to the old tuple-record definition.

In 29 we add a pragma that emits migration code that makes the record syntax
accept both native and tuple records. Then in 31 we can change to native
records as 29 + 30 will then be able to accept them.

### Ordering and equality

With addition of native-record the runtime values of different types are now ordered as follows:

```
number()
< atom()
< reference()
< fun()
< port()
< pid()
< tuple()
< record()
< map()
< []
< [_|_]
< bitstring()
```

Native-record values are ordered by their fully qualified name, then by their visibility, then by their opacity,
then their keys and finally by field values (field values are considered as maps).
Equality is defined through equality of all the properties: names, visibility, opacity, keys and field values.

> **NOTE**: Comparison will be done in key order

### Reflection

A new module native-records provides functionality for basic runtime reflection. This is a very
preliminary sketch of how it may look:

```erlang
-module(records).
-spec get_module(record()) -> module().
-spec get_name(record()) -> atom().
-spec is_exported(record()) -> boolean().
-spec get_field_names(record()) -> [atom()].
-spec get(record(), atom()) -> dynamic().
-spec create(Module :: module(), RecordName :: atom(), FieldsMap :: #{atom() => term()}) -> record().
-spec create(Module :: module(), RecordName :: atom(), FieldsMap :: #{atom() => term()}, Options :: #{ exported => boolean() }) -> record().
```

This part needs more thought about enforcing and bypassing visibility (exported and private native-record definitions) and opacity.

- It should provide a means to work with any native-record through reflection, but bypassing visibility and opacity restrictions should be explicit.

The functions in the native-records module are BIFs.

### Printing

Here is how printed native-records will look like:

```erlang
% native-record
#users:user{id = 1, name = "Alice", city = "London"}
```

Printing of fields follows the field order. Whether a native-record value is
exported or not is not visible through printing.

### External term format

External term format is extended to support serialization of native-record values.

### Tooling

While the compiler doesn’t validate native-record operations at compile time, theshe validations can be
easily performed through simple linting that ensures:

- The visibility of native-records is respected (a non-exported native-record definition is not used outside of the defining module)
- The opacity of native-records is respected
- Fields are used correctly

All of these checks are straightforward, and xref can be easily extended to handle them.

### Performance characteristics

While the implementation of native-records is a large scope, from the runtime perspective they are
much closer to maps than to records (tuples). So, their performance characteristics should align
with maps (with insignificant overhead for runtime validation). Additionally, given that
native-records are more specialized versions of maps (with all keys being atoms), there's potential for optimizations

<!--

Rational
========

```erlang
-module(mod).
-record #state{ foo, bar }.
%% Parameterized state
-record #state(T){ foo :: T, bar :: T }.
%% You export a record in order to allow another module to create it using syntax.
%% Other modules can still create such records using the `record` module for
%% debugging purposes.
-export([#state/0]).
%% Only export the foo field from the state record? This would apply 
-export(#state/1, [foo]).

init() ->
  #state{}.

update(State) ->
  #state{ foo = 1 }.

%% Fields are ordered according to declaration
position(State) ->
  1 = #state.foo,
  2 = #state.bar.
```

In another module through import:

```erlang
-import(mod, [#state/0]).
init() ->
  #state{}.

update(State) ->
  State#state{ foo = 1 }.

%% Fields are ordered according to declaration
%% This makes it easier for ets tables to use
%% them as indexes and we could also allow doing
%% `element(integer(), Record)` so to keep even
%% more compatibility with tuple-records.
position(State) ->
  1 = #state.foo,
  2 = #state.bar.
```

In another module through explicit syntax:

```erlang
init() ->
  #mod:state{}.

update(State) ->
  State#mod:state{ foo = 1 }.

%% Fields are ordered according to declaration
position(State) ->
  foo = #mod:state.foo,
  bar = #mod:state.bar.
```

With the above proposal we can update #read_file_info to be a
native-record by changing the include file to have an `-import_record`
statement and then have that native-record in the `file` module.
Sending the record over distribution will of course be a problem if both
sides do not use the same version of Erlang. Though that problem you have
already today, only that we don't change the read_file_info record all
that much.

Native-record names can also be reserved words and "Atom"
(atom starting with capital letter without needing to be quoted).

When creating a native record the definition used for creation depends
on whether it is created using the local or remote syntax. Just as for
modules calls if you do `#state{}` you will get the definition in the
current module, while if you do `#mod:state{}` you will get the latest
definition. Native record creation in an other module will always be
remote as `-import_record` is just syntactic sugar.

When updating a native record you will always keep the current definition.
If you want to upgrade a record to use a newer version, you should do so
by creating a new record using the `#mod:state{}` syntax and then migrating
the fields from the old to the new.

-->

Incompatibilities with tuple-records
====================================

1. Native-record creation cannot be done in guards as this would mean that
   we would need to do function calls in guards. Tuple-records allow functions
   to be default values as the compiler will complain that it cannot create such
   records at compile-time if used in a guard, but as native-record creation only
   happens at run-time it cannot be allowed at all.
2. `element/2` and `#Module:Name.Field` will work with atoms for native-records
   and not indexes.

Thoughts to consider
====================

Problems with native records
----------------------------

* Default values require a lookup into the defining module, and the default
  values can in turn be other native-records or even function calls. If we
  put this together with code upgrade you can get some very strange behaviours
  where a native record with three fields using the same native-record could
  end up with three different versions of that native-record.

Should we also include protocols?
---------------------------------

You can read more here: https://hexdocs.pm/elixir/protocols.html

But basically, protocols is very similar in purpose (not implementation)
to interfaces in Java, in that they allow a common library to work on unknown
user-defined types. For example we have the Enumerable protocol that works for any
thing that it is possible to enumerate, i.e. lists, maps, array,
proplists, gb_trees etc etc. There is also the 'String.Chars' protocol
that returns the term as a string.

You can define a protocol implementation for any base datatype (list, map,
tuple, float) and for any specific Elixir struct.

One key feature is that you can define the protocol implementation separately
from both the protocol definition and the datatype.

I'm not sure what the syntax would look like in Erlang where the only thing we
have are functions... but maybe something like this.

Protocol definition:

```erlang
-module(string).
-export_protocol([to_string/1]).
-export([to_string/1]).
```

Protocol implementation for #array native-record

```erlang
-module(array_printer).
-import(array, [#array/0]).
-protocol(string, #array/0).
to_string(#array{}) ->
  unicode:characters_to_binary(
    io_lib:format("#array:array{ ~tp }",
      [array:to_list(Array)])).
```

And this would be used like this:

```erlang
1> Arr = array:set(0, a, array:new()).
#array:array{ [a] } %% Note that the shell uses the to_string protocol!
2> string:to_string(Arr).
<<"#array:array{ [a] }">>
```

There would need to be run-time support for resolving where a protocol
implementation is.

How much of the stdlib should we aim to update?
-----------------------------------------------

With native-records, there are many places that we would like to have
records instead of returning bare tuples. Calendar and dates come to mind,
also compound things such as array, gb_sets, gb_trees, and probably many more.

Should there be some autoimported native-records? like `#ok`, `#error`, `#exception`?

Some of the base things in how the stdlib and Erlang code is built would be
completely different with the access of native-records and especially if we
also add protocols...

How much compile time checking should we do?
--------------------------------------------

tuple-records have checking of keys at compile time. The more dynamic
we make native-records, the less compile time checking can we do.
We don't want to end up with the same compile time dependencies as
behaviours/parse_transforms.

The proposal in this EEP would allow for compile-time checks within the
owning module, but not in other modules.

Should we have some private fields?
-----------------------------------

Should it be possible to hide some fields from being accessed
though syntax? Or should that be the job of the typesystem?

Debugging/printing tools will always be able to get the fields and their values.

What do we do about nodes that do not support native-records?
-------------------------------------------------------------

We could convert to a map with a "special" field with record
metadata. For maps we converted to a proplist, there was no
possible round-trip. Maybe that is enough here as well?

We can also convert the native-record to a tuple-record. By doing this we will
loose being able to roundtrip, but old code would be able to handle the
native-records. 

Access/update without record name
---------------------------------

```erlang
%% Below the compiler can "deduce" the type of S.
lookup(#state{} = S) ->
   S#foo.
```

or

```erlang
%% More dynamic, though harder for type systems to reason about.
lookup(S) ->
   S#foo.

%% Adding a spec would of course fix that, but it becomes more complicated
%% when a native-record is a return value.
-spec lookup(#state{}) -> integer().

%% Chain lookups?
chain_lookup(S) ->
   S#foo#bar.
```

<!-- -->

```erlang
%% Can the same syntax be used for updates?
update(#state{} = S) ->
   S1 = S#foo = 1,
   S1#foo#bar = 1.
```

Should large records be trees?
------------------------------

When a map becomes large, it switches to a tree so that
updating an element does not entail a full copy of all
values. Do we want the same for native-records?

Alternate Designs
=================

We could create yet another type, lets call it structs that has the same behaviour
only that the declaration is -struct everywhere.

Reference Implementation
========================


Backward Compatibility
======================

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
[VimVar]: <> " vim: set fileencoding=utf-8 expandtab shiftwidth=4 softtabstop=4: "
