    Author: Lukas Backstr√∂m <lukas@erlang.org>
    Status: 
    Type: Standards Track
    Created: 26-Nov-2024
    Erlang-Version: OTP-29.0
    Post-History:
****
EEP 75: Native records
----

Abstract
========

This EEP proposes to make records a native datatype to Erlang instead
of a layer on top of tuples. The old tuple-records will remain for
backwards compatibility but the purpose of the native-records is to
replace all current usages of tuple-records. Native-records are tied
to a specific module and use the same syntax as tuple-records except
for declaration.

Rationale
=========

```erlang
-module(mod).
-record #state{ foo, bar }.
%% Parameterized state
-record #state(T){ foo :: T }.
%% What does record export mean? Debugging tools will still need access...
-export_record([state/0]).

init() ->
  #state{}.

update(State) ->
  State#state{ foo = 1 }.

%% Fields are ordered according to declaration
position(State) ->
  1 = #state.foo,
  2 = #state.bar.
```

In another module through import:

```erlang
-import_record(mod, [state/0]).
init() ->
  #state{}.

update(State) ->
  State#state{ foo = 1 }.

%% Fields are ordered according to declaration
%% This makes it easier for ets tables to use
%% them as indexes and we could also allow doing
%% `element(integer(), Record)` so to keep even
%% more compatibility with tuple-records.
position(State) ->
  1 = #state.foo,
  2 = #state.bar.
```

In another module through explicit syntax:


```erlang
init() ->
  #mod:state{}.

update(State) ->
  State#mod:state{ foo = 1 }.

%% Fields are ordered according to declaration
position(State) ->
  1 = #mod:state.foo,
  2 = #mod:state.bar.
```

With the above proposal we can update #read_file_info to be a
native-record by changing the include file to have an `-import_record`
statement and then have that native-record in the `file` module.
Sending the record over distribution will of course be a problem if both
sides do not use the same version of Erlang. Though that problem you have
already today, only that we don't change the read_file_info record all
that much.

Native-record names can also be reserved words and "Atom"
(atom starting with capital letter without needing to be quoted).

Thoughts to consider
====================

How much compile time checking should we do?
--------------------------------------------

tuple-records have checking of keys at compile time. The more dynamic
we make native-records, the less compile time checking can we do.
We don't want to end up with the same compile time dependencies as
behaviours/parse_transforms.

Should we have some private fields?
-----------------------------------

Should it be possible to hide some fields from being accessed
though syntax? Or should that be the job of the typesystem?

Debugging/printing tools will always be able to get the fields and their values.

What do we do about nodes that do not support native-records?
-------------------------------------------------------------

We could convert to a map with a "special" field with record
metadata. For maps we converted to a proplist, there was no
possible round-trip. Maybe that is enough here as well?

Access/update without record name
---------------------------------

```erlang
%% Below the compiler can "deduce" the type of S.
lookup(#state{} = S) ->
   S#foo.

or

%% More dynamic, though harder for type systems to reason about.
lookup(S) ->
   S#foo.

%% Adding a spec would of course fix that, but it becomes more complicated
%% when a native-record is a return value.
-spec lookup(#state{}) -> integer().

%% Chain lookups?
chain_lookup(S) ->
   S#foo#bar.
```

```erlang
%% Can the same syntax be used for updates?
update(#state{} = S) ->
   S1 = S#foo = 1,
   S1#foo#bar = 1.
```

Should large records be trees?
------------------------------

When a map becomes large, it switches to a tree so that
updating an element does not entail a full copy of all
values. Do we want the same for native-records?

Alternate Designs
=================

We could create yet another type, lets call it structs that has the same behaviour
only that the declaration is -struct everywhere.

Reference Implementation
========================


Backward Compatibility
======================

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
[VimVar]: <> " vim: set fileencoding=utf-8 expandtab shiftwidth=4 softtabstop=4: "
