    Author: Lukas Backstr√∂m <lukas@erlang.org>
    Status: 
    Type: Standards Track
    Created: 26-Nov-2024
    Erlang-Version: OTP-29.0
    Post-History:
****
EEP 75: Native records
----

Abstract
========

This EEP proposes to make records a native datatype to Erlang instead
of a layer on top of tuples. The old tuple-records will remain for
backwards compatibility but the purpose of the native-records is to
replace all current usages of tuple-records. Native-records are tied
to a specific module and use the same syntax as tuple-records except
for declaration.

Rationale
=========

```erlang
-module(mod).
-record #state{ foo, bar }.
%% Parameterized state
-record #state(T){ foo :: T }.
%% What does record export mean? Debugging tools will still need access...
-export([#state/0]).

init() ->
  #state{}.

update(State) ->
  State#state{ foo = 1 }.

%% Fields are ordered according to declaration
position(State) ->
  1 = #state.foo,
  2 = #state.bar.
```

In another module through import:

```erlang
-import(mod, [#state/0]).
init() ->
  #state{}.

update(State) ->
  State#state{ foo = 1 }.

%% Fields are ordered according to declaration
%% This makes it easier for ets tables to use
%% them as indexes and we could also allow doing
%% `element(integer(), Record)` so to keep even
%% more compatibility with tuple-records.
position(State) ->
  1 = #state.foo,
  2 = #state.bar.
```

In another module through explicit syntax:


```erlang
init() ->
  #mod:state{}.

update(State) ->
  State#mod:state{ foo = 1 }.

%% Fields are ordered according to declaration
position(State) ->
  1 = #mod:state.foo,
  2 = #mod:state.bar.
```

With the above proposal we can update #read_file_info to be a
native-record by changing the include file to have an `-import_record`
statement and then have that native-record in the `file` module.
Sending the record over distribution will of course be a problem if both
sides do not use the same version of Erlang. Though that problem you have
already today, only that we don't change the read_file_info record all
that much.

Native-record names can also be reserved words and "Atom"
(atom starting with capital letter without needing to be quoted).

Thoughts to consider
====================

Should we also include protocols?
---------------------------------

You can read more here: https://hexdocs.pm/elixir/protocols.html

But basically, protocols is very similar to interfaces in Java,
in that they allow a common library to work on unknown user-defined
types. For example we have the Enumerable protocol that works for any
thing that it is possible to enumerate, i.e. lists, maps, array,
proplists, gb_trees etc etc. There is also the 'String.Chars' protocol
that returns the term as a string.

You can define a protocol implementation for any base datatype (list, map,
tuple, float) and for any specific Elixir struct.

One key feature is that you can define the protocol implementation separately
from both the protocol definition and the datatype.

I'm not sure what the syntax would look like in Erlang where the only thing we
have are functions... but maybe something like this.

Protocol definition:

```erlang
-module(string).
-export_protocol([to_string/1]).
-export([to_string/1]).
```

Protocol implementation for #array native-record

```erlang
-module(array_printer).
-import(array, [#array/0]).
-protocol(string, #array/0).
to_string(#array{}) ->
  unicode:characters_to_binary(
    io_lib:format("#array:array{ ~tp }",
      [array:to_list(Array)])).
```

And this would be used like this:

```erlang
1> Arr = array:set(0, a, array:new()).
#array:array{ [a] } %% Note that the shell uses the to_string protocol!
2> string:to_string(Arr).
<<"#array:array{ [a] }">>
```

There would need to be run-time support for resolving where a protocol
implementation is.

How much of the stdlib should we aim to update?
-----------------------------------------------

With native-records, there are many places that we would like to have
records instead of returning bare tuples. Calendar and dates come to mind,
also compound things such as array, gb_sets, gb_trees, and probably many more.

Should there be some autoimported native-records? like `#ok`, `#error`, `#exception`?

Some of the base things in how the stdlib and Erlang code is built would be
completely different with the access of native-records and especially if we
also add protocols...

How much compile time checking should we do?
--------------------------------------------

tuple-records have checking of keys at compile time. The more dynamic
we make native-records, the less compile time checking can we do.
We don't want to end up with the same compile time dependencies as
behaviours/parse_transforms.

Should we have some private fields?
-----------------------------------

Should it be possible to hide some fields from being accessed
though syntax? Or should that be the job of the typesystem?

Debugging/printing tools will always be able to get the fields and their values.

What do we do about nodes that do not support native-records?
-------------------------------------------------------------

We could convert to a map with a "special" field with record
metadata. For maps we converted to a proplist, there was no
possible round-trip. Maybe that is enough here as well?

Access/update without record name
---------------------------------

```erlang
%% Below the compiler can "deduce" the type of S.
lookup(#state{} = S) ->
   S#foo.

or

%% More dynamic, though harder for type systems to reason about.
lookup(S) ->
   S#foo.

%% Adding a spec would of course fix that, but it becomes more complicated
%% when a native-record is a return value.
-spec lookup(#state{}) -> integer().

%% Chain lookups?
chain_lookup(S) ->
   S#foo#bar.
```

```erlang
%% Can the same syntax be used for updates?
update(#state{} = S) ->
   S1 = S#foo = 1,
   S1#foo#bar = 1.
```

Should large records be trees?
------------------------------

When a map becomes large, it switches to a tree so that
updating an element does not entail a full copy of all
values. Do we want the same for native-records?

Alternate Designs
=================

We could create yet another type, lets call it structs that has the same behaviour
only that the declaration is -struct everywhere.

Reference Implementation
========================


Backward Compatibility
======================

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
[VimVar]: <> " vim: set fileencoding=utf-8 expandtab shiftwidth=4 softtabstop=4: "
